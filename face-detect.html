<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Locker — Face / Eye / Voice Lock (Demo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600&display=swap" rel="stylesheet">
<style>
  :root{--bg:#071021;--panel:#0f1722;--accent:#33d6a6;--muted:#9aa4b2}
  *{box-sizing:border-box}html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#06101a,#071022);color:#eaf6f1}
  .wrap{max-width:980px;margin:16px auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:12px;border-radius:12px}
  .video-wrap{position:relative;border-radius:10px;overflow:hidden;background:#000}
  video, canvas{width:100%;height:auto;display:block}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{background:var(--accent);color:#042022;border:0;padding:10px 12px;border-radius:8px;font-weight:600;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  .steps{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  .step{padding:8px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-weight:600}
  .step.ok{background:linear-gradient(90deg,var(--accent),#28b083);color:#042022}
  .files{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .file-row{display:flex;justify-content:space-between;gap:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);align-items:center}
  input[type=file]{display:block}
  @media (max-width:720px){ .wrap{padding:8px} button{flex:1} .steps{flex-direction:column} }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Locker Demo — Multi-Biometric (face • eye • voice)</strong><div class="small">CYBER CITY — local demo only</div></div>
      <div class="small">No biometric data leaves your device</div>
    </div>
  </div>

  <div class="panel video-wrap" id="videoPanel">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="panel">
    <div class="small">Progress</div>
    <div class="steps" id="steps">
      <div class="step" id="faceStep">Face lock</div>
      <div class="step" id="eyeStep">Eye scan</div>
      <div class="step" id="voiceStep">Voice access</div>
    </div>

    <div class="controls" style="margin-top:6px">
      <button id="startCam">Start Camera</button>
      <button id="stopCam" disabled>Stop</button>
      <button id="resetBtn">Reset</button>
      <div style="margin-left:auto" class="small" id="status">Model not loaded</div>
    </div>

    <div style="margin-top:12px" class="small">Voice passphrase (say exactly): <strong id="phrase">open sesame</strong></div>
  </div>

  <div class="panel" id="lockerPanel" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Locker — unlocked</strong><div class="small">Store files locally (IndexedDB)</div></div>
      <div><button id="lockBtn">Lock</button></div>
    </div>

    <div style="margin-top:8px" class="small">Add files / photos</div>
    <input id="fileInput" type="file" multiple />
    <div class="files" id="fileList"></div>
  </div>

  <div class="panel small">Notes: This is a client-side demo. Do NOT use as a real security system. It checks presence, an eye-movement gesture, and a spoken passphrase locally.</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js"></script>
<script>
(async ()=> {
  // elements
  const video = document.getElementById('video'), canvas = document.getElementById('overlay'), ctx = canvas.getContext('2d');
  const startCam = document.getElementById('startCam'), stopCam = document.getElementById('stopCam'), resetBtn = document.getElementById('resetBtn');
  const statusEl = document.getElementById('status');
  const faceStep = document.getElementById('faceStep'), eyeStep = document.getElementById('eyeStep'), voiceStep = document.getElementById('voiceStep');
  const lockerPanel = document.getElementById('lockerPanel'), lockBtn = document.getElementById('lockBtn');
  const fileInput = document.getElementById('fileInput'), fileList = document.getElementById('fileList');
  const phraseEl = document.getElementById('phrase');

  // demo parameters
  const FACE_CONF = 0.85;
  const EYE_MOVE_DIST = 30; // px movement to register left->right
  const EYE_WINDOW_MS = 4000;

  // state
  let model = null, stream = null, running=false, lastDetections=[], trackedFace=null;
  let facePassed=false, eyePassed=false, voicePassed=false;
  let eyePositions = [], eyeTimer = null;

  // load model
  statusEl.textContent = 'Loading face model...';
  try { model = await blazeface.load(); statusEl.textContent = 'Model ready'; } catch(e){ statusEl.textContent='Model failed'; console.error(e); }

  function resizeCanvas(){ canvas.width = video.videoWidth || 640; canvas.height = video.videoHeight || 480; canvas.style.width = video.clientWidth + 'px'; }

  async function startCamera(){
    if (running) return;
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream; await video.play();
      running = true; startCam.disabled=true; stopCam.disabled=false; statusEl.textContent='Detecting...';
      resizeCanvas(); requestAnimationFrame(loop);
    } catch(e){ statusEl.textContent='Camera denied/unavailable'; console.error(e); }
  }
  function stopCamera(){ running=false; startCam.disabled=false; stopCam.disabled=true; statusEl.textContent='Stopped'; if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null;} ctx.clearRect(0,0,canvas.width,canvas.height); }

  startCam.addEventListener('click', startCamera); stopCam.addEventListener('click', stopCamera);
  resetBtn.addEventListener('click', ()=>{ facePassed=eyePassed=voicePassed=false; updateSteps(); stopCamera(); });

  // simple IndexedDB file store
  const DB_NAME = 'cyber-locker', STORE='files';
  let db;
  function openDB(){ return new Promise((res,rej)=> {
    const r = indexedDB.open(DB_NAME,1);
    r.onupgradeneeded = ()=> r.result.createObjectStore(STORE, { keyPath:'id', autoIncrement:true });
    r.onsuccess = ()=> { db = r.result; res(db); };
    r.onerror = e => rej(e);
  }); }
  async function addFile(file){ if(!db) await openDB(); const tx=db.transaction(STORE,'readwrite'); const s=tx.objectStore(STORE); s.add({name:file.name, type:file.type, blob:file}); tx.oncomplete=()=> loadFiles(); }
  async function loadFiles(){ fileList.innerHTML=''; if(!db) await openDB(); const tx=db.transaction(STORE,'readonly'); const s=tx.objectStore(STORE); const req=s.openCursor(); req.onsuccess = e => { const cur=e.target.result; if(cur){ const r=cur.value; const row=document.createElement('div'); row.className='file-row'; row.innerHTML = `<div style="flex:1">${r.name} <span class="small">(${r.type || 'file'})</span></div>`; const b=document.createElement('div'); const dl=document.createElement('button'); dl.textContent='Download'; dl.onclick=()=> { const url=URL.createObjectURL(r.blob); const a=document.createElement('a'); a.href=url; a.download=r.name; a.click(); URL.revokeObjectURL(url); }; const del=document.createElement('button'); del.textContent='Delete'; del.onclick=()=>{ const dtx=db.transaction(STORE,'readwrite'); dtx.objectStore(STORE).delete(r.id); dtx.oncomplete=()=> loadFiles(); }; b.appendChild(dl); b.appendChild(del); row.appendChild(b); fileList.appendChild(row); cur.continue(); } }; }
  fileInput.addEventListener('change', e=> { const files = Array.from(e.target.files); files.forEach(f=> addFile(f)); e.target.value=''; });
  lockBtn.addEventListener('click', ()=>{ facePassed=eyePassed=voicePassed=false; updateSteps(); lockerPanel.style.display='none'; stopCamera(); });

  // voice recognition (passphrase)
  const PASS_PHRASE = 'open sesame';
  phraseEl.textContent = PASS_PHRASE;
  let recognition = null;
  function startVoiceCheck(){
    voicePassed = false; updateSteps();
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SpeechRecognition){ statusEl.textContent='Voice not supported'; return; }
    recognition = new SpeechRecognition(); recognition.lang = 'en-US'; recognition.interimResults = false; recognition.maxAlternatives = 1;
    statusEl.textContent='Listening for passphrase...';
    recognition.onresult = (ev)=> {
      const txt = ev.results[0][0].transcript.trim().toLowerCase();
      if(txt === PASS_PHRASE.toLowerCase()){ voicePassed=true; statusEl.textContent='Voice passed'; updateSteps(); checkAll(); } else { statusEl.textContent='Phrase mismatch: "'+txt+'"'; }
    };
    recognition.onerror = (e)=> { statusEl.textContent='Voice error'; console.error(e); };
    recognition.onend = ()=> { if(!voicePassed) statusEl.textContent='Voice listening ended'; };
    recognition.start();
  }

  // eye-scan: require user to move gaze left then right (measured by eye-center x)
  function pushEye(x){ eyePositions.push({t:Date.now(), x}); // remove old
    const cutoff = Date.now()-EYE_WINDOW_MS; eyePositions = eyePositions.filter(p=>p.t>cutoff);
    // detect left->right: exists earlier x < mid - dist and later x > mid + dist
    if(eyePositions.length<3) return;
    const xs = eyePositions.map(p=>p.x); const min = Math.min(...xs), max = Math.max(...xs);
    if((max - min) > EYE_MOVE_DIST){ eyePassed=true; statusEl.textContent='Eye scan passed'; updateSteps(); checkAll(); eyePositions=[]; }
  }

  function updateSteps(){
    faceStep.className = 'step' + (facePassed ? ' ok' : '');
    eyeStep.className  = 'step' + (eyePassed  ? ' ok' : '');
    voiceStep.className= 'step' + (voicePassed? ' ok' : '');
    if(facePassed && eyePassed && voicePassed){ statusEl.textContent='All checks passed — unlocking...'; lockerPanel.style.display='block'; loadFiles(); }
  }

  // main loop: detect faces and landmarks
  async function loop(){
    if(!running) return;
    try {
      const predictions = await model.estimateFaces(video, false);
      lastDetections = predictions;
      resizeCanvas();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if(predictions && predictions.length>0){
        // draw boxes
        predictions.forEach(pred=>{
          const [x1,y1]=pred.topLeft, [x2,y2]=pred.bottomRight;
          ctx.lineWidth=2; ctx.strokeStyle='rgba(51,214,166,0.9)'; ctx.strokeRect(x1,y1,x2-x1,y2-y1);
          if(pred.landmarks && pred.landmarks.length>=2){
            // landmarks: rightEye, leftEye, nose...
            const re = pred.landmarks[0], le = pred.landmarks[1];
            ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(re[0],re[1],3,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(le[0],le[1],3,0,Math.PI*2); ctx.fill();
            const eyeCenterX = (re[0]+le[0])/2;
            // push positions for eye-scan
            pushEye(eyeCenterX);
          }
          // face presence check
          const prob = pred.probability && pred.probability[0] ? pred.probability[0] : 1;
          if(prob >= FACE_CONF) { facePassed = true; statusEl.textContent = 'Face detected'; updateSteps(); }
        });
      } else {
        // no faces
        statusEl.textContent = 'No face detected';
      }
    } catch(e){ console.error(e); }
    requestAnimationFrame(loop);
  }

  function checkAll(){ updateSteps(); if(facePassed && eyePassed && voicePassed){ statusEl.textContent='Unlocked — locker open'; } }

  // UI: on unlocking, start voice check automatically
  // Start voice when face+eye passed but voice not yet
  const observer = new MutationObserver(()=>{ if(facePassed && eyePassed && !voicePassed) startVoiceCheck(); });
  observer.observe(document.getElementById('steps'), { attributes: true, subtree:true, childList:true });

  // auto start voice when user clicks startCam and face/eye passed
  // init DB
  openDB().then(()=> loadFiles()).catch(()=>{ /* ignore */ });
})();
</script>
</body>
</html>